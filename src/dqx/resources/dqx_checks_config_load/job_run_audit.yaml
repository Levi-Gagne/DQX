# resources/dqx_checks_config/job_run_audit.yaml

# --- Keys / presence ----------------------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: business_fields_not_null
  criticality: error
  run_config_name: default
  check:
    function: is_not_null
    for_each_column:
      - job_name
      - job_id
      - run_id
      - start_time
      - start_date
      - state
      - result_state
      - start_time_raw
      - run_page_url
      - creator
      - launched_by
  # SQL (violation counts per column; run each block as needed):
  # -- job_name
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE job_name IS NULL;
  # -- job_id
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE job_id IS NULL;
  # -- run_id
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE run_id IS NULL;
  # -- start_time
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_time IS NULL;
  # -- start_date
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_date IS NULL;
  # -- state
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE state IS NULL;
  # -- result_state
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE result_state IS NULL;
  # -- start_time_raw
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_time_raw IS NULL;
  # -- run_page_url
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE run_page_url IS NULL;
  # -- creator
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE creator IS NULL;
  # -- launched_by
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE launched_by IS NULL;
  # -- Inspect (example):
  # SELECT * FROM dq_prd.monitoring.job_run_audit WHERE job_name IS NULL LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: run_id_is_unique
  criticality: error
  run_config_name: default
  check:
    function: is_unique
    arguments:
      columns: [run_id]
  # SQL (violation rows only; counts all rows in duplicate groups, excludes NULLs):
  # SELECT COUNT(*) AS violation_count
  # FROM (
  #   SELECT run_id, COUNT(*) OVER (PARTITION BY run_id) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit
  # ) t
  # WHERE run_id IS NOT NULL AND kcnt > 1;
  # -- Inspect rows:
  # SELECT *
  # FROM (
  #   SELECT t.*, COUNT(*) OVER (PARTITION BY run_id) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit t
  # ) x
  # WHERE run_id IS NOT NULL AND kcnt > 1;

# --- Temporal correctness -----------------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_not_in_future
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_time <= current_timestamp()"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time > current_timestamp();
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time > current_timestamp()
  # ORDER BY start_time DESC LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: start_date_not_in_future
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_date <= current_date()"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_date > current_date();
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE start_date > current_date()
  # ORDER BY start_date DESC LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: start_date_matches_start_time_date
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_date = date(start_time)"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (start_date = DATE(start_time));
  # -- Inspect:
  # SELECT start_date, start_time, * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (start_date = DATE(start_time)) LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: end_after_or_equal_start
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "end_time IS NULL OR end_time >= start_time"
  # SQL (violation rows only; end < start when end is present):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE end_time IS NOT NULL AND end_time < start_time;
  # -- Inspect:
  # SELECT start_time, end_time, * FROM dq_prd.monitoring.job_run_audit
  # WHERE end_time IS NOT NULL AND end_time < start_time LIMIT 100;

# --- State/result logic -------------------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: state_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: state
      allowed: ["PENDING","RUNNING","TERMINATING","TERMINATED"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state IS NOT NULL
  #   AND state NOT IN ('PENDING','RUNNING','TERMINATING','TERMINATED');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state IS NOT NULL
  #   AND state NOT IN ('PENDING','RUNNING','TERMINATING','TERMINATED') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: result_state_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: result_state
      allowed: ["SUCCESS","FAILED","CANCELED","SKIPPED","TIMEDOUT","INTERNAL_ERROR"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state IS NOT NULL
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','SKIPPED','TIMEDOUT','INTERNAL_ERROR');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state IS NOT NULL
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','SKIPPED','TIMEDOUT','INTERNAL_ERROR') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: terminated_runs_have_end_time
  criticality: error
  run_config_name: default
  filter: "state = 'TERMINATED'"
  check:
    function: sql_expression
    arguments:
      expression: "end_time IS NOT NULL"
  # SQL (violation rows only under filter state='TERMINATED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED' AND end_time IS NULL;
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED' AND end_time IS NULL LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: result_state_allowed_when_terminated
  criticality: error
  run_config_name: default
  filter: "state = 'TERMINATED'"
  check:
    function: is_in_list
    arguments:
      column: result_state
      allowed: ["SUCCESS","FAILED","CANCELED","INTERNAL_ERROR"]
  # SQL (violation rows only under filter state='TERMINATED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED'
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','INTERNAL_ERROR');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED'
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','INTERNAL_ERROR') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: failed_runs_have_error_code
  criticality: error
  run_config_name: default
  filter: "result_state = 'FAILED'"
  check:
    function: sql_expression
    arguments:
      expression: "error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a'"
  # SQL (violation rows only under filter result_state='FAILED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: failed_runs_have_notifications
  criticality: error
  run_config_name: default
  filter: "result_state = 'FAILED'"
  check:
    function: sql_expression
    arguments:
      expression: "(msteams_notification = 1) OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a')"
  # SQL (violation rows only under filter result_state='FAILED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (msteams_notification = 1
  #            OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a'));
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (msteams_notification = 1
  #            OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a')) LIMIT 100;

# --- Launch/schedule semantics ------------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: launched_by_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: launched_by
      allowed: ["MANUAL","SCHEDULED","PERIODIC","API","WORKFLOW","RETRY"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by IS NOT NULL
  #   AND launched_by NOT IN ('MANUAL','SCHEDULED','PERIODIC','API','WORKFLOW','RETRY');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by IS NOT NULL
  #   AND launched_by NOT IN ('MANUAL','SCHEDULED','PERIODIC','API','WORKFLOW','RETRY') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: periodic_runs_require_schedule
  criticality: error
  run_config_name: default
  filter: "launched_by = 'PERIODIC'"
  check:
    function: sql_expression
    arguments:
      expression: "schedule_type = 'quartz_cron_expression' AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a'"
  # SQL (violation rows only under filter launched_by='PERIODIC'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by = 'PERIODIC'
  #   AND NOT (schedule_type = 'quartz_cron_expression'
  #            AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by = 'PERIODIC'
  #   AND NOT (schedule_type = 'quartz_cron_expression'
  #            AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a') LIMIT 100;

# --- URL / identity formatting -----------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: run_page_url_is_https
  criticality: error
  run_config_name: default
  check:
    function: regex_match
    arguments:
      column: run_page_url
      regex: "^https://.+"
  # SQL (violation rows only; HTTPS required):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE run_page_url IS NOT NULL
  #   AND run_page_url NOT RLIKE '^https://.+';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE run_page_url IS NOT NULL
  #   AND run_page_url NOT RLIKE '^https://.+' LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: creator_is_email_or_na
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(creator)) = 'n/a' OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$'"
  # SQL (violation rows only; must be 'n/a' or an email-looking string):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(creator)) = 'n/a'
  #            OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(creator)) = 'n/a'
  #            OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: run_id_safe_charset
  criticality: error
  run_config_name: default
  check:
    function: regex_match
    arguments:
      column: run_id
      regex: "^[A-Za-z0-9_.:\\-]+$"
  # SQL (violation rows only; restrict to safe chars):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE run_id IS NOT NULL
  #   AND run_id NOT RLIKE '^[A-Za-z0-9_.:\\-]+$';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE run_id IS NOT NULL
  #   AND run_id NOT RLIKE '^[A-Za-z0-9_.:\\-]+$' LIMIT 100;

# --- Raw time integrity -------------------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_raw_is_positive
  criticality: error
  run_config_name: default
  check:
    function: is_in_range
    arguments:
      column: start_time_raw
      min_limit: 1
  # SQL (violation rows only; NULL or < 1):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NULL OR start_time_raw < 1;
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NULL OR start_time_raw < 1 LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_raw_matches_start_time
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "ABS(start_time_raw - unix_timestamp(start_time) * 1000) <= 60000"
  # SQL (violation rows only; > 60s drift, exclude NULLs):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NOT NULL
  #   AND start_time IS NOT NULL
  #   AND ABS(start_time_raw - unix_timestamp(start_time) * 1000) > 60000;
  # -- Inspect:
  # SELECT start_time_raw, start_time, *
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NOT NULL
  #   AND start_time IS NOT NULL
  #   AND ABS(start_time_raw - unix_timestamp(start_time) * 1000) > 60000
  # LIMIT 100;

# --- Functional consistency / dataset-level ----------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: job_name_maps_to_single_job_id
  criticality: error
  run_config_name: default
  check:
    function: sql_query
    arguments:
      query: >
        SELECT a.*
        FROM {{table}} a
        INNER JOIN (
          SELECT job_name, MIN(job_id) AS min_id, MAX(job_id) AS max_id
          FROM {{table}}
          GROUP BY job_name
          HAVING MIN(job_id) <> MAX(job_id)
        ) b
        ON a.job_name = b.job_name
      limit: 1000000
  # SQL (violation rows only; all rows for job_names mapping to >1 job_id):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit a
  # INNER JOIN (
  #   SELECT job_name
  #   FROM dq_prd.monitoring.job_run_audit
  #   GROUP BY job_name
  #   HAVING MIN(job_id) <> MAX(job_id)
  # ) b
  # ON a.job_name = b.job_name;
  # -- Inspect:
  # SELECT a.*
  # FROM dq_prd.monitoring.job_run_audit a
  # INNER JOIN (
  #   SELECT job_name
  #   FROM dq_prd.monitoring.job_run_audit
  #   GROUP BY job_name
  #   HAVING MIN(job_id) <> MAX(job_id)
  # ) b
  # ON a.job_name = b.job_name
  # ORDER BY a.job_name, a.start_time DESC
  # LIMIT 1000;

- table_name: dq_prd.monitoring.job_run_audit
  name: unique_job_id_start_time
  criticality: error
  run_config_name: default
  check:
    function: is_unique
    arguments:
      columns: [job_id, start_time]
  # SQL (violation rows only; counts all rows in duplicate groups, excludes NULL pairs):
  # SELECT COUNT(*) AS violation_count
  # FROM (
  #   SELECT job_id, start_time,
  #          COUNT(*) OVER (PARTITION BY job_id, start_time) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit
  # ) t
  # WHERE job_id IS NOT NULL AND start_time IS NOT NULL AND kcnt > 1;
  # -- Inspect rows:
  # SELECT *
  # FROM (
  #   SELECT t.*,
  #          COUNT(*) OVER (PARTITION BY job_id, start_time) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit t
  # ) x
  # WHERE job_id IS NOT NULL AND start_time IS NOT NULL AND kcnt > 1;

# --- Business strings not "n/a"/empty ----------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: key_strings_not_na_or_empty
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: >
        lower(trim(job_name)) <> 'n/a' AND trim(job_name) <> '' AND
        lower(trim(job_id)) <> 'n/a'   AND trim(job_id)   <> '' AND
        lower(trim(run_page_url)) <> 'n/a' AND trim(run_page_url) <> ''
  # SQL (violation rows only; any of these are 'n/a' or empty strings):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE lower(trim(job_name))    = 'n/a' OR trim(job_name)    = ''
  #    OR lower(trim(job_id))      = 'n/a' OR trim(job_id)      = ''
  #    OR lower(trim(run_page_url))= 'n/a' OR trim(run_page_url)= '';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE lower(trim(job_name))    = 'n/a' OR trim(job_name)    = ''
  #    OR lower(trim(job_id))      = 'n/a' OR trim(job_id)      = ''
  #    OR lower(trim(run_page_url))= 'n/a' OR trim(run_page_url)= '' LIMIT 200;

# --- Duration formats (tolerant) ---------------------------------------------
- table_name: dq_prd.monitoring.job_run_audit
  name: duration_hms_or_na
  criticality: warn
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$'"
  # SQL (violation rows only; duration not 'n/a' and not HH:MM:SS[.ms]):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$') LIMIT 100;

- table_name: dq_prd.monitoring.job_run_audit
  name: queue_duration_hms_or_na
  criticality: warn
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$'"
  # SQL (violation rows only; queue_duration not 'n/a' and not HH:MM:SS[.ms]):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$') LIMIT 100;