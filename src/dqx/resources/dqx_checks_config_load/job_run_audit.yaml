# resources/dqx_checks_config/job_run_audit.yaml

# --- Keys / presence ----------------------------------------------------------
# DESCRIPTION: Core business columns must be present (not NULL).
#  - Trigger Condition: Any row where one of the listed business columns is NULL.
- table_name: dq_prd.monitoring.job_run_audit
  name: business_fields_not_null
  criticality: error
  run_config_name: default
  check:
    function: is_not_null
    for_each_column:
      - job_name
      - job_id
      - run_id
      - start_time
      - start_date
      - state
      - result_state
      - start_time_raw
      - run_page_url
      - creator
      - launched_by
  # SQL (violation counts per column; run each block as needed):
  # -- job_name
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE job_name IS NULL;
  # -- job_id
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE job_id IS NULL;
  # -- run_id
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE run_id IS NULL;
  # -- start_time
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_time IS NULL;
  # -- start_date
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_date IS NULL;
  # -- state
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE state IS NULL;
  # -- result_state
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE result_state IS NULL;
  # -- start_time_raw
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE start_time_raw IS NULL;
  # -- run_page_url
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE run_page_url IS NULL;
  # -- creator
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE creator IS NULL;
  # -- launched_by
  # SELECT COUNT(*) FROM dq_prd.monitoring.job_run_audit WHERE launched_by IS NULL;
  # -- Inspect (example):
  # SELECT * FROM dq_prd.monitoring.job_run_audit WHERE job_name IS NULL LIMIT 100;

# DESCRIPTION: run_id must be globally unique.
#  - Trigger Condition: Any duplicate run_id among non-NULL values.
- table_name: dq_prd.monitoring.job_run_audit
  name: run_id_is_unique
  criticality: error
  run_config_name: default
  check:
    function: is_unique
    arguments:
      columns: [run_id]
  # SQL (violation rows only; counts all rows in duplicate groups, excludes NULLs):
  # SELECT COUNT(*) AS violation_count
  # FROM (
  #   SELECT run_id, COUNT(*) OVER (PARTITION BY run_id) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit
  # ) t
  # WHERE run_id IS NOT NULL AND kcnt > 1;
  # -- Inspect rows:
  # SELECT *
  # FROM (
  #   SELECT t.*, COUNT(*) OVER (PARTITION BY run_id) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit t
  # ) x
  # WHERE run_id IS NOT NULL AND kcnt > 1;

# --- Temporal correctness -----------------------------------------------------
# DESCRIPTION: start_time cannot be in the future.
#  - Trigger Condition: start_time > current_timestamp().
- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_not_in_future
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_time <= current_timestamp()"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time > current_timestamp();
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time > current_timestamp()
  # ORDER BY start_time DESC LIMIT 100;

# DESCRIPTION: start_date cannot be in the future.
#  - Trigger Condition: start_date > current_date().
- table_name: dq_prd.monitoring.job_run_audit
  name: start_date_not_in_future
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_date <= current_date()"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_date > current_date();
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE start_date > current_date()
  # ORDER BY start_date DESC LIMIT 100;

# DESCRIPTION: start_date must equal DATE(start_time).
#  - Trigger Condition: start_date != DATE(start_time).
- table_name: dq_prd.monitoring.job_run_audit
  name: start_date_matches_start_time_date
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "start_date = date(start_time)"
  # SQL (violation rows only):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (start_date = DATE(start_time));
  # -- Inspect:
  # SELECT start_date, start_time, * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (start_date = DATE(start_time)) LIMIT 100;

# DESCRIPTION: end_time must be ≥ start_time when present.
#  - Trigger Condition: end_time IS NOT NULL AND end_time < start_time.
- table_name: dq_prd.monitoring.job_run_audit
  name: end_after_or_equal_start
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "end_time IS NULL OR end_time >= start_time"
  # SQL (violation rows only; end < start when end is present):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE end_time IS NOT NULL AND end_time < start_time;
  # -- Inspect:
  # SELECT start_time, end_time, * FROM dq_prd.monitoring.job_run_audit
  # WHERE end_time IS NOT NULL AND end_time < start_time LIMIT 100;

# --- State/result logic -------------------------------------------------------
# DESCRIPTION: state must be one of fixed lifecycle values.
#  - Trigger Condition: state NOT IN ('PENDING','RUNNING','TERMINATING','TERMINATED').
- table_name: dq_prd.monitoring.job_run_audit
  name: state_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: state
      allowed: ["PENDING","RUNNING","TERMINATING","TERMINATED"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state IS NOT NULL
  #   AND state NOT IN ('PENDING','RUNNING','TERMINATING','TERMINATED');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state IS NOT NULL
  #   AND state NOT IN ('PENDING','RUNNING','TERMINATING','TERMINATED') LIMIT 100;

# DESCRIPTION: result_state must be one of fixed terminal values.
#  - Trigger Condition: result_state NOT IN ('SUCCESS','FAILED','CANCELED','SKIPPED','TIMEDOUT','INTERNAL_ERROR').
- table_name: dq_prd.monitoring.job_run_audit
  name: result_state_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: result_state
      allowed: ["SUCCESS","FAILED","CANCELED","SKIPPED","TIMEDOUT","INTERNAL_ERROR"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state IS NOT NULL
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','SKIPPED','TIMEDOUT','INTERNAL_ERROR');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state IS NOT NULL
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','SKIPPED','TIMEDOUT','INTERNAL_ERROR') LIMIT 100;

# DESCRIPTION: TERMINATED runs must have an end_time.
#  - Trigger Condition: state='TERMINATED' AND end_time IS NULL.
- table_name: dq_prd.monitoring.job_run_audit
  name: terminated_runs_have_end_time
  criticality: error
  run_config_name: default
  filter: "state = 'TERMINATED'"
  check:
    function: sql_expression
    arguments:
      expression: "end_time IS NOT NULL"
  # SQL (violation rows only under filter state='TERMINATED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED' AND end_time IS NULL;
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED' AND end_time IS NULL LIMIT 100;

# DESCRIPTION: When state='TERMINATED', result_state must be terminal (not SKIPPED/TIMEDOUT).
#  - Trigger Condition: state='TERMINATED' AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','INTERNAL_ERROR').
- table_name: dq_prd.monitoring.job_run_audit
  name: result_state_allowed_when_terminated
  criticality: error
  run_config_name: default
  filter: "state = 'TERMINATED'"
  check:
    function: is_in_list
    arguments:
      column: result_state
      allowed: ["SUCCESS","FAILED","CANCELED","INTERNAL_ERROR"]
  # SQL (violation rows only under filter state='TERMINATED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED'
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','INTERNAL_ERROR');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE state = 'TERMINATED'
  #   AND result_state NOT IN ('SUCCESS','FAILED','CANCELED','INTERNAL_ERROR') LIMIT 100;

# DESCRIPTION: FAILED runs must carry an error_code or non-empty error text (not 'n/a').
#  - Trigger Condition: result_state='FAILED' AND (error_code IS NULL OR empty/'n/a').
- table_name: dq_prd.monitoring.job_run_audit
  name: failed_runs_have_error_code
  criticality: error
  run_config_name: default
  filter: "result_state = 'FAILED'"
  check:
    function: sql_expression
    arguments:
      expression: "error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a'"
  # SQL (violation rows only under filter result_state='FAILED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (error_code IS NOT NULL AND trim(error_code) <> '' AND lower(trim(error_code)) <> 'n/a') LIMIT 100;

# DESCRIPTION: FAILED runs must have at least one notification configured (Teams flag=1 or non-empty email list).
#  - Trigger Condition: result_state='FAILED' AND no Teams AND no valid email_notification.
- table_name: dq_prd.monitoring.job_run_audit
  name: failed_runs_have_notifications
  criticality: error
  run_config_name: default
  filter: "result_state = 'FAILED'"
  check:
    function: sql_expression
    arguments:
      expression: "(msteams_notification = 1) OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a')"
  # SQL (violation rows only under filter result_state='FAILED'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (msteams_notification = 1
  #            OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a'));
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE result_state = 'FAILED'
  #   AND NOT (msteams_notification = 1
  #            OR (email_notification IS NOT NULL AND trim(email_notification) <> '' AND lower(trim(email_notification)) <> 'n/a')) LIMIT 100;

# --- Launch/schedule semantics ------------------------------------------------
# DESCRIPTION: launched_by must be one of the allowed triggers.
#  - Trigger Condition: launched_by NOT IN ('MANUAL','SCHEDULED','PERIODIC','API','WORKFLOW','RETRY').
- table_name: dq_prd.monitoring.job_run_audit
  name: launched_by_allowed_values
  criticality: error
  run_config_name: default
  check:
    function: is_in_list
    arguments:
      column: launched_by
      allowed: ["MANUAL","SCHEDULED","PERIODIC","API","WORKFLOW","RETRY"]
  # SQL (violation rows only; exact match, case-sensitive):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by IS NOT NULL
  #   AND launched_by NOT IN ('MANUAL','SCHEDULED','PERIODIC','API','WORKFLOW','RETRY');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by IS NOT NULL
  #   AND launched_by NOT IN ('MANUAL','SCHEDULED','PERIODIC','API','WORKFLOW','RETRY') LIMIT 100;

# DESCRIPTION: PERIODIC launches must have a quartz cron schedule populated.
#  - Trigger Condition: launched_by='PERIODIC' AND (schedule_type/schedule missing or invalid).
- table_name: dq_prd.monitoring.job_run_audit
  name: periodic_runs_require_schedule
  criticality: error
  run_config_name: default
  filter: "launched_by = 'PERIODIC'"
  check:
    function: sql_expression
    arguments:
      expression: "schedule_type = 'quartz_cron_expression' AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a'"
  # SQL (violation rows only under filter launched_by='PERIODIC'):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by = 'PERIODIC'
  #   AND NOT (schedule_type = 'quartz_cron_expression'
  #            AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE launched_by = 'PERIODIC'
  #   AND NOT (schedule_type = 'quartz_cron_expression'
  #            AND schedule IS NOT NULL AND trim(schedule) <> '' AND lower(trim(schedule)) <> 'n/a') LIMIT 100;

# --- URL / identity formatting -----------------------------------------------
# DESCRIPTION: run_page_url must be HTTPS.
#  - Trigger Condition: run_page_url NOT RLIKE '^https://.+' (when non-NULL).
- table_name: dq_prd.monitoring.job_run_audit
  name: run_page_url_is_https
  criticality: error
  run_config_name: default
  check:
    function: regex_match
    arguments:
      column: run_page_url
      regex: "^https://.+"
  # SQL (violation rows only; HTTPS required):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE run_page_url IS NOT NULL
  #   AND run_page_url NOT RLIKE '^https://.+';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE run_page_url IS NOT NULL
  #   AND run_page_url NOT RLIKE '^https://.+' LIMIT 100;

# DESCRIPTION: creator must be 'n/a' or look like an email address.
#  - Trigger Condition: creator not 'n/a' and not a basic email pattern.
- table_name: dq_prd.monitoring.job_run_audit
  name: creator_is_email_or_na
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(creator)) = 'n/a' OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$'"
  # SQL (violation rows only; must be 'n/a' or an email-looking string):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(creator)) = 'n/a'
  #            OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(creator)) = 'n/a'
  #            OR creator RLIKE '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$') LIMIT 100;

# DESCRIPTION: run_id must be composed of a safe character set (alnum, _, ., :, -).
#  - Trigger Condition: run_id not matching the safe regex (when non-NULL).
- table_name: dq_prd.monitoring.job_run_audit
  name: run_id_safe_charset
  criticality: error
  run_config_name: default
  check:
    function: regex_match
    arguments:
      column: run_id
      regex: "^[A-Za-z0-9_.:\\-]+$"
  # SQL (violation rows only; restrict to safe chars):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE run_id IS NOT NULL
  #   AND run_id NOT RLIKE '^[A-Za-z0-9_.:\\-]+$';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE run_id IS NOT NULL
  #   AND run_id NOT RLIKE '^[A-Za-z0-9_.:\\-]+$' LIMIT 100;

# --- Raw time integrity -------------------------------------------------------
# DESCRIPTION: start_time_raw must be within inclusive [1, BIGINT_MAX].
#  - Trigger Condition: start_time_raw IS NULL or < 1 or > BIGINT_MAX.
- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_raw_is_in_valid_range
  criticality: error
  run_config_name: default
  check:
    function: is_in_range
    arguments:
      column: start_time_raw
      min_limit: 1
      max_limit: 9223372036854775807
  # SQL (violation rows only; DQX bounds are inclusive):
  # -- inclusive_min/max are implicit in DQX for is_in_range
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NULL
  #    OR start_time_raw <  1
  #    OR start_time_raw >  9223372036854775807;
  # -- Inspect:
  # SELECT *
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NULL
  #    OR start_time_raw <  1
  #    OR start_time_raw >  9223372036854775807
  # LIMIT 100;

# DESCRIPTION: start_time_raw should match start_time within ±60s (millis vs epoch).
#  - Trigger Condition: both columns present AND |start_time_raw - unix_ts(start_time)*1000| > 60000.
- table_name: dq_prd.monitoring.job_run_audit
  name: start_time_raw_matches_start_time
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "ABS(start_time_raw - unix_timestamp(start_time) * 1000) <= 60000"
  # SQL (violation rows only; > 60s drift, exclude NULLs):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NOT NULL
  #   AND start_time IS NOT NULL
  #   AND ABS(start_time_raw - unix_timestamp(start_time) * 1000) > 60000;
  # -- Inspect:
  # SELECT start_time_raw, start_time, *
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE start_time_raw IS NOT NULL
  #   AND start_time IS NOT NULL
  #   AND ABS(start_time_raw - unix_timestamp(start_time) * 1000) > 60000
  # LIMIT 100;

# --- Functional consistency / dataset-level ----------------------------------
# DESCRIPTION: Each job_name should map to exactly one job_id (no ID churn).
#  - Trigger Condition: Any job_name where MIN(job_id) <> MAX(job_id); all rows for that job_name are flagged.
- table_name: dq_prd.monitoring.job_run_audit
  name: job_name_maps_to_single_job_id
  criticality: error
  run_config_name: default
  check:
    function: sql_query
    arguments:
      query: |
        SELECT
          job_name,
          CASE WHEN MIN(job_id) = MAX(job_id) THEN TRUE ELSE FALSE END AS condition
        FROM {{ input_view }}
        GROUP BY job_name
      merge_columns: [job_name]
      condition_column: condition
      # input_placeholder: input_view   # optional; defaults to 'input_view'
      # msg: "job_name must map to a single job_id"
  # SQL (violation rows only; all rows for job_names mapping to >1 job_id):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit a
  # INNER JOIN (
  #   SELECT job_name
  #   FROM dq_prd.monitoring.job_run_audit
  #   GROUP BY job_name
  #   HAVING MIN(job_id) <> MAX(job_id)
  # ) b
  # ON a.job_name = b.job_name;
  # -- Inspect:
  # SELECT a.*
  # FROM dq_prd.monitoring.job_run_audit a
  # INNER JOIN (
  #   SELECT job_name
  #   FROM dq_prd.monitoring.job_run_audit
  #   GROUP BY job_name
  #   HAVING MIN(job_id) <> MAX(job_id)
  # ) b
  # ON a.job_name = b.job_name
  # ORDER BY a.job_name, a.start_time DESC
  # LIMIT 1000;

# DESCRIPTION: (Uniqueness) No duplicate runs per (job_id, start_time).
#  - Trigger Condition: Any duplicate pair (job_id, start_time) among non-NULL pairs.
- table_name: dq_prd.monitoring.job_run_audit
  name: unique_job_id_start_time
  criticality: error
  run_config_name: default
  check:
    function: is_unique
    arguments:
      columns: [job_id, start_time]
  # SQL (violation rows only; counts all rows in duplicate groups, excludes NULL pairs):
  # SELECT COUNT(*) AS violation_count
  # FROM (
  #   SELECT job_id, start_time,
  #          COUNT(*) OVER (PARTITION BY job_id, start_time) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit
  # ) t
  # WHERE job_id IS NOT NULL AND start_time IS NOT NULL AND kcnt > 1;
  # -- Inspect rows:
  # SELECT *
  # FROM (
  #   SELECT t.*,
  #          COUNT(*) OVER (PARTITION BY job_id, start_time) AS kcnt
  #   FROM dq_prd.monitoring.job_run_audit t
  # ) x
  # WHERE job_id IS NOT NULL AND start_time IS NOT NULL AND kcnt > 1;

# --- Business strings not "n/a"/empty ----------------------------------------
# DESCRIPTION: Key business strings cannot be 'n/a' or empty.
#  - Trigger Condition: Any of job_name, job_id, run_page_url are blank or 'n/a'.
- table_name: dq_prd.monitoring.job_run_audit
  name: key_strings_not_na_or_empty
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: >
        lower(trim(job_name)) <> 'n/a' AND trim(job_name) <> '' AND
        lower(trim(job_id)) <> 'n/a'   AND trim(job_id)   <> '' AND
        lower(trim(run_page_url)) <> 'n/a' AND trim(run_page_url) <> ''
  # SQL (violation rows only; any of these are 'n/a' or empty strings):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE lower(trim(job_name))    = 'n/a' OR trim(job_name)    = ''
  #    OR lower(trim(job_id))      = 'n/a' OR trim(job_id)      = ''
  #    OR lower(trim(run_page_url))= 'n/a' OR trim(run_page_url)= '';
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE lower(trim(job_name))    = 'n/a' OR trim(job_name)    = ''
  #    OR lower(trim(job_id))      = 'n/a' OR trim(job_id)      = ''
  #    OR lower(trim(run_page_url))= 'n/a' OR trim(run_page_url)= '' LIMIT 200;

# --- Duration formats (tolerant) ---------------------------------------------
# DESCRIPTION: duration must be 'n/a' or an HH:MM:SS[.ms] string.
#  - Trigger Condition: duration not 'n/a' and not matching ^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\.[0-9]{1,3})?$.
- table_name: dq_prd.monitoring.job_run_audit
  name: duration_hms_or_na
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$'"
  # SQL (violation rows only; duration not 'n/a' and not HH:MM:SS[.ms]):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(duration)) = 'n/a' OR duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$') LIMIT 100;

# DESCRIPTION: queue_duration must be 'n/a' or an HH:MM:SS[.ms] string.
#  - Trigger Condition: queue_duration not 'n/a' and not matching the HH:MM:SS[.ms] regex.
- table_name: dq_prd.monitoring.job_run_audit
  name: queue_duration_hms_or_na
  criticality: error
  run_config_name: default
  check:
    function: sql_expression
    arguments:
      expression: "lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$'"
  # SQL (violation rows only; queue_duration not 'n/a' and not HH:MM:SS[.ms]):
  # SELECT COUNT(*) AS violation_count
  # FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$');
  # -- Inspect:
  # SELECT * FROM dq_prd.monitoring.job_run_audit
  # WHERE NOT (lower(trim(queue_duration)) = 'n/a' OR queue_duration RLIKE '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?$') LIMIT 100;